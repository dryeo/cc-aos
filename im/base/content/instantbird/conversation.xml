<?xml version="1.0"?>
<!-- ***** BEGIN LICENSE BLOCK *****
   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
   -
   - The contents of this file are subject to the Mozilla Public License Version
   - 1.1 (the "License"); you may not use this file except in compliance with
   - the License. You may obtain a copy of the License at
   - http://www.mozilla.org/MPL/
   -
   - Software distributed under the License is distributed on an "AS IS" basis,
   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   - for the specific language governing rights and limitations under the
   - License.
   -
   - The Original Code is the Instantbird messenging client, released
   - 2007.
   -
   - The Initial Developer of the Original Code is
   - Florian QUEZE <florian@instantbird.org>.
   - Portions created by the Initial Developer are Copyright (C) 2007
   - the Initial Developer. All Rights Reserved.
   -
   - Contributor(s):
   -
   - Alternatively, the contents of this file may be used under the terms of
   - either the GNU General Public License Version 2 or later (the "GPL"), or
   - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   - in which case the provisions of the GPL or the LGPL are applicable instead
   - of those above. If you wish to allow use of your version of this file only
   - under the terms of either the GPL or the LGPL, and not to allow others to
   - use your version of this file under the terms of the MPL, indicate your
   - decision by deleting the provisions above and replace them with the notice
   - and other provisions required by the GPL or the LGPL. If you do not delete
   - the provisions above, a recipient may use your version of this file under
   - the terms of any one of the MPL, the GPL or the LGPL.
   -
   - ***** END LICENSE BLOCK ***** -->


<!DOCTYPE bindings [
  <!ENTITY % instantbirdDTD SYSTEM "chrome://instantbird/locale/instantbird.dtd">
  %instantbirdDTD;
]>

<bindings id="conversationBindings"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="conversation">
    <resources>
      <stylesheet src="chrome://instantbird/skin/instantbird.css"/>
    </resources>
    <content>
      <xul:vbox class="convBox" flex="1">
        <xul:hbox class="topPart" flex="1">
          <xul:browser flex="5" class="browser" anonid="browser" type="content"/>
          <xul:splitter anonid="splitter" collapse="after" class="splitter chatOnly">
            <xul:grippy/>
          </xul:splitter>
          <xul:vbox class="chatOnly" width="150">
            <xul:hbox>
              <xul:label class="header" value="&chat.participants;"/>
              <xul:textbox flex="1" readonly="true" class="plain" anonid="participantCount"/>
            </xul:hbox>
            <xul:listbox flex="1" anonid="nicklist"/>
          </xul:vbox>
        </xul:hbox>
        <xul:splitter class="splitter"/>
        <xul:deck anonid="conv-bottom" class="conv-bottom" selectedIndex="1">
          <xul:vbox>
            <xul:toolbar anonid="conv-toolbar">
              <xul:toolbarbutton label="Bold" oncommand="this.editorDoCommand('bold');"/>
              <xul:toolbarbutton label="Italic" oncommand="this.editorDoCommand('italic');"/>
              <xul:toolbarbutton label="Underline" oncommand="this.editorDoCommand('underline');"/>
            </xul:toolbar>
            <xul:editor anonid="editor" editortype="html" src="about:blank" flex="1"/>
          </xul:vbox>
          <xul:textbox anonid="input" multiline="true" spellcheck="true" flex="1"/>
        </xul:deck>
      </xul:vbox>
    </content>
    <implementation implements="nsIWebProgressListener,nsIObserver">
     <constructor>
      <![CDATA[
       document.getAnonymousElementByAttribute(this, "anonid", "input")
               .addEventListener("keypress", this.onSendMsg, false);

       var browser = document.getAnonymousElementByAttribute(this, "anonid", "browser");
       browser.addEventListener("keypress", this.browserKeyPress, false);

       var docShell = browser.docShell;
       docShell.allowJavascript = false;
       docShell.allowAuth = false;
       docShell.allowPlugins = false;
       docShell.allowMetaRedirects = false;
       docShell.allowSubframes = false;
       docShell.allowImages = false;

       // load the stylesheet through the style sheet service to workaround
       // a security restriction in 1.9b2+ (bug 397791)
       var sss = Components.classes["@mozilla.org/content/style-sheet-service;1"]
                           .getService(Components.interfaces.nsIStyleSheetService);
       var uri = Components.classes["@mozilla.org/network/io-service;1"]
                           .getService(Components.interfaces.nsIIOService)
                           .newURI("chrome://instantbird/skin/conv.css", null, null);
       if (!sss.sheetRegistered(uri, sss.USER_SHEET)) 
         sss.loadAndRegisterSheet(uri, sss.USER_SHEET);

       var url = 'data:text/html,<html><head></head><body id="ibcontent"></body></html>';
       browser.setAttribute("src", url);//"chrome://instantbird/content/conv.html"
       browser.addProgressListener(this);

       var editor = document.getAnonymousElementByAttribute(this, "anonid", "editor");
       editor.addEventListener("keypress", this.onSendHTMLMsg, false);
       //this doesn't work at the moment
       //editor.contentDocument.designMode = "on";
       //setTimeout(function() { editor.contentWindow.focus(); }, 100);
      ]]>
     </constructor>

     <destructor>
      <![CDATA[
        this._conv.close();
        this._conv.removeObserver(this);
      ]]>
     </destructor>

     <field name="loaded">false</field>
     <field name="messageQueue">[]</field>

     <method name="addMsg">
      <parameter name="aMsg"/>
      <body>
      <![CDATA[
        if (this.loaded)
          this._addMsg(aMsg);
        else
          this.messageQueue.push(aMsg);
      ]]>
      </body>
     </method>

     <method name="_addMsg">
      <parameter name="aMsg"/>
      <body>
      <![CDATA[
        var conv = aMsg.conversation;
        if (!conv) {
          // The conversation has already been destroyed,
          // probably because the window was closed.
          // Return without doing anything.
          return;
        }
        var time = aMsg.time;
        var name = aMsg.alias ||aMsg.who;

        var msgClass = [];
        if (aMsg.system)
          msgClass.push("system");
        if (aMsg.containsNick)
          msgClass.push("nick");
        var txt = '<span class="date">' + time + '</span> ';

        var msg = aMsg.message;
        if (!aMsg.noLinkification) {
          msg = Components.classes["@mozilla.org/txttohtmlconv;1"]
                          .getService(Ci.mozITXTToHTMLConv)
                          .scanHTML(msg, 2)
                          .replace(/&amp;(apos|quot);/g, "&$1;");
        }

        var me = msg.match("^/me(.*)");
        if (!aMsg.system) {
          var pseudoClass = "pseudo";
          var color = "";
          if (aMsg.incoming) {
            if (conv instanceof Ci.purpleIConvChat)
              color = " style=\"color: hsl(" + this.buddies[name].color + ", 100%, 50%)\"";
            else
              pseudoClass += " incoming";
          }
          else
            if (aMsg.outgoing)
              pseudoClass += " outgoing";

          txt += '<span class="' + pseudoClass + '"' + color + '>' + name  + (me ? "</span> " : ":</span> ");
        }

        txt += (me ? me[1] : msg).replace(/\n/g, "<br/>");
        if (me)
          msgClass.push("me");

        this._addTxt(txt, msgClass.join(" "));

        if (this.tab && !this.tab.selected && aMsg.incoming && !aMsg.system) {
          if (conv instanceof Ci.purpleIConvChat && aMsg.containsNick)
            this.tab.setAttribute("attention", "true");
          else
            this.tab.setAttribute("unread", "true");
        }
      ]]>
      </body>
     </method>

     <method name="_addTxt">
      <parameter name="aTxt"/>
      <parameter name="aClass"/>
      <body>
      <![CDATA[
        if (!this.loaded)
          throw "Trying to append text to a not yet loaded browser";

        var browser = document.getAnonymousElementByAttribute(this, "anonid", "browser");
        var doc = browser.contentDocument;
        var elt = doc.getElementById("ibcontent");
        var newElt = doc.createElement("p");
        newElt.innerHTML = aTxt;
        newElt.className = aClass;
        newElt.setAttribute("aria-live", "polite");
        var shouldScroll = elt.scrollHeight == elt.scrollTop + elt.clientHeight;
        elt.appendChild(newElt);
        if (shouldScroll)
          newElt.scrollIntoView(true);
      ]]>
      </body>
     </method>

     <method name="sendMsg">
      <parameter name="aMsg"/>
      <body>
      <![CDATA[
        var re = /^\/raw (.*)/;
        var msg = aMsg.match(re);
        if (msg)
          msg = msg[1];
        else
          msg = Components.classes["@mozilla.org/txttohtmlconv;1"]
                          .getService(Ci.mozITXTToHTMLConv)
                          .scanTXT(aMsg, 0);
        this._conv.sendMsg(msg);
      ]]>
      </body>
     </method>

     <method name="onSendMsg">
      <parameter name="event"/>
      <body>
      <![CDATA[
        if (event.keyCode != 13)
          return;

        /* "this" can point to the textbox when this method is used by an eventListener,
            get the conversation element */
        var conv = this;
        if (this.localName != "conversation")
          conv = document.getBindingParent(this);

        var input = document.getAnonymousElementByAttribute(conv, "anonid", "input");
        if (!event.ctrlKey && !event.shiftKey && !event.altKey) {
          conv.sendMsg(input.value);
          input.value = "";
          event.preventDefault();
        }
        else if (!event.shiftKey)
          conv.addString("\n");
      ]]>
      </body>
     </method>

     <method name="onSendHTMLMsg">
      <parameter name="event"/>
      <body>
      <![CDATA[
        if (event.keyCode != 13)
          return;

        /* "this" can point to the textbox when this method is used by an eventListener,
            get the conversation element */
        var conv = this;
        if (this.localName != "conversation")
          conv = document.getBindingParent(this);

        var editor = this.getEditor(this.contentWindow);
        var docRoot = editor.rootElement;

        if (!event.ctrlKey && !event.shiftKey && !event.altKey) {
          conv.sendMsg(docRoot.innerHTML);
          docRoot.innerHTML = "";
          event.preventDefault();
        }
        else {
          if (!event.shiftKey)
            // unfortunately, this doesn't work
            this.contentDocument.execCommand("inserthtml", false, "<br>");
        }
      ]]>
      </body>
     </method>

     <method name="editorDoCommand">
      <parameter name="aCmd"/>
      <parameter name="aHtml"/>
      <body>
      <![CDATA[
        var editor = document.getAnonymousElementByAttribute(this, "anonid", "editor");
        editor.contentDocument.execCommand(aCmd, false, aHtml);
      ]]>
      </body>
     </method>

     <method name="browserKeyPress">
     <parameter name="event"/>
      <body>
      <![CDATA[
#ifndef XP_MACOSX
        var accelKeyPressed = event.ctrlKey;
#else
        var accelKeyPressed = event.metaKey;
#endif
        // 118 is the decimal code for "v" character, 13 keyCode for "return" key
        if (((accelKeyPressed && event.charCode != 118) || event.altKey) &&
            event.keyCode != 13)
          return;

        var conv = document.getBindingParent(this);
        var isHtmlMode = conv.isHtmlMode;
        var editor = conv.editor;

        // "Return" key
        if (event.keyCode == 13) {
          editor.focus();

          if (isHtmlMode)
            conv.onSendHTMLMsg(event);
          else
            conv.onSendMsg(event);

          // Alt and Ctrl + return are handled in onSendMsg
          if (event.shiftKey) {
            if (!isHtmlMode)
              conv.addString("\n");
          }
        }
        // "Backspace" key
        else if (event.keyCode == 8) {
          editor.focus();

          if (!isHtmlMode) {
            if (editor.selectionStart > 0 &&
                editor.selectionStart == editor.selectionEnd)
              --editor.selectionStart;

            conv.addString("");
          }
        }
        // "Delete" key
        else if (event.keyCode == 46) {
          editor.focus();

          if (!isHtmlMode) {
            var length = editor.textLength;
            if (editor.selectionStart < length &&
                editor.selectionStart == editor.selectionEnd)
              ++editor.selectionEnd;

            conv.addString("");
          }
        }

        // CharCode=0 means not a character
        if (event.charCode == 0)
          return;

        editor.focus();

        // Returns for Ctrl+V
        if (accelKeyPressed)
          return;

        if (!isHtmlMode)
          conv.addString(String.fromCharCode(event.charCode));
      ]]>
      </body>
     </method>

     <!-- Replace the current selection in the editor by the given string -->
     <method name="addString">
       <parameter name="aString"/>
       <body>
       <![CDATA[
         var editor = this.editor;
         var length = (aString != "")
                      ? aString.length
                      : 0;

         var cursorPosition = editor.selectionStart + length;

         editor.value = editor.value.substr(0, editor.selectionStart) + aString +
                        editor.value.substr(editor.selectionEnd);
         editor.selectionStart = editor.selectionEnd = cursorPosition;
       ]]>
       </body>
     </method>

     <!-- Update the participant count of a chat conversation -->
     <method name="updateParticipantCount">
       <body>
       <![CDATA[
         document.getAnonymousElementByAttribute(this, "anonid", "participantCount").value =
           this.buddies.__count__;
       ]]>
       </body>
     </method>

     <!-- Set the attributes (flags) of a chat buddy -->
     <method name="setBuddyAttributes">
       <parameter name="aItem"/>
       <body>
       <![CDATA[
         var buddy = aItem.chatBuddy;
         var image;
         if (!buddy.noFlags) {
           if (buddy.op)
             image = "operator";
           else if (buddy.halfOp)
             image = "half-operator";
           else if (buddy.voiced)
             image = "voice";
           else if (buddy.founder)
             image = "founder";
         }
         if (image)
           aItem.setAttribute("image", "chrome://instantbird/skin/" + image + ".png");
         else
           aItem.removeAttribute("image");
       ]]>
       </body>
     </method>

     <!-- Add a buddy in the visible list of participants -->
     <method name="addBuddy">
       <parameter name="aBuddy"/>
       <body>
       <![CDATA[
         var name = aBuddy.name;
         if (this.buddies.hasOwnProperty(name))
           throw "Adding a chat buddy twice?!";
         var item = document.createElement("listitem");
         item.chatBuddy = aBuddy;
         item.setAttribute("class", "listitem-iconic");
         item.setAttribute("label", name);
         this.setBuddyAttributes(item);

         // Compute the color based on the nick
         var nick = name.match(/[a-zA-Z0-9]+/)[0].toLowerCase();
         var weight = 10;
         var res = 0;
         for (var i = 0; i < nick.length; ++i) {
           var char = nick.charCodeAt(i) - 47;
           if (char > 10)
             char -= 39;
           // now char contains a value between 1 and 36
           res += char * weight;
           weight *= 0.52; //arbitrary
         }
         res = Math.round(res) % 360;
         var style = "color: hsl(" + res + ", 100%, 50%);";
         item.setAttribute("style", style);
         item.color = res;

         this.buddies[name] = item;
         var nicklist = document.getAnonymousElementByAttribute(this, "anonid", "nicklist");
         nicklist.appendChild(item); //FIXME insert at the right position
         this.updateParticipantCount();
       ]]>
       </body>
     </method>

     <!-- Update a buddy in the visible list of participants -->
     <method name="updateBuddy">
       <parameter name="aBuddy"/>
       <parameter name="aOldName"/>
       <body>
       <![CDATA[
         var name = aBuddy.name;
         if (!aOldName) {
           // If aOldName is null, we are changing the flags of the buddy
           var item = this.buddies[name];
           item.chatBuddy = aBuddy;
           this.setBuddyAttributes(item);
           return;
         }

         // Is aOldName is not null, then we are renaming the buddy
         if (!this.buddies.hasOwnProperty(aOldName))
           throw "Updating a chat buddy that does not exist?!";

         if (this.buddies.hasOwnProperty(name))
           throw "Updating a chat buddy to an already existing one?!";

         var item = this.buddies[aOldName];
         item.chatBuddy = aBuddy;
         delete this.buddies[aOldName];
         this.buddies[name] = item;
         item.setAttribute("label", name);

         // FIXME: move this item to the right position if its name changed
       ]]>
       </body>
     </method>
     <method name="removeBuddy">
       <parameter name="aName"/>
       <body>
       <![CDATA[
         if (!this.buddies.hasOwnProperty(aName))
           throw "Cannot remove a buddy that was not in the room";
         var item = this.buddies[aName];
         item.parentNode.removeChild(item);
         delete this.buddies[aName];
         this.updateParticipantCount();
       ]]>
       </body>
     </method>

     <!-- nsIObserver implementation -->
     <method name="observe">
       <parameter name="aSubject"/>
       <parameter name="aTopic"/>
       <parameter name="aData"/>
       <body>
       <![CDATA[
         if (!this.loaded)
           return;

         switch(aTopic) {
         case "new-text":
           this._addMsg(aSubject.QueryInterface(Ci.purpleIMessage));
           break;

         case "chat-buddy-add":
           this.addBuddy(aSubject.QueryInterface(Ci.purpleIConvChatBuddy));
           break;

         case "chat-buddy-remove":
           this.removeBuddy(aData);
           break;

         case "chat-buddy-update":
           this.updateBuddy(aSubject.QueryInterface(Ci.purpleIConvChatBuddy), aData);
           break;
         }
       ]]>
       </body>
     </method>

     <!-- nsIWebProgressListener implementation -->
     <method name="onStateChange">
      <parameter name="aProgress"/>
      <parameter name="aRequest"/>
      <parameter name="aStateFlags"/>
      <parameter name="aStatus"/>
      <body>
      <![CDATA[
        const WPL = Components.interfaces.nsIWebProgressListener;
        if ((aStateFlags & WPL.STATE_IS_DOCUMENT) &&
            (aStateFlags & WPL.STATE_STOP)) {
          var browser = document.getAnonymousElementByAttribute(this, "anonid", "browser");
          browser.removeProgressListener(this);
          this.loaded = true;
          for (var i = 0; i < this.messageQueue.length; ++i)
            this._addMsg(this.messageQueue[i]);
          this.messageQueue = null;

          if (this._conv instanceof Components.interfaces.purpleIConvChat) {
            this.setAttribute("chat", "true");
            this.buddies = {};
            var nicks = getIter(this.conv.getParticipants, Ci.purpleIConvChatBuddy);
            for (n in nicks)
              this.addBuddy(n);
          }
        }
      ]]>
      </body>
     </method>

     <method name="onProgressChange">
      <parameter name="aProgress"/>
      <parameter name="aRequest"/>
      <parameter name="aCurSelf"/>
      <parameter name="aMaxSelf"/>
      <parameter name="aCurTotal"/>
      <parameter name="aMaxTotal"/>
     </method>

     <method name="onLocationChange">
      <parameter name="aProgress"/>
      <parameter name="aRequest"/>
      <parameter name="aLocation"/>
     </method>

     <method name="onStatusChange">
      <parameter name="aProgress"/>
      <parameter name="aRequest"/>
      <parameter name="aStatus"/>
      <parameter name="aMessage"/>
     </method>

     <method name="onSecurityChange">
      <parameter name="aProgress"/>
      <parameter name="aRequest"/>
      <parameter name="aState"/>
     </method>

     <property name="convId">
       <getter>
         <![CDATA[
           return this._conv.id;
         ]]>
       </getter>
     </property>

     <property name="conv">
       <getter>
         <![CDATA[
           return this._conv;
         ]]>
       </getter>
       <setter>
         <![CDATA[
           if (this._conv)
             throw("Already initialized");
           this._conv = val;
           this._conv.addObserver(this);
           return val;
         ]]>
       </setter>
     </property>

     <property name="isHtmlMode">
       <getter>
         <![CDATA[
           var editorIndex = document.getAnonymousElementByAttribute(this, "anonid", "conv-bottom")
                                     .selectedIndex;
           return (editorIndex == "0");
         ]]>
       </getter>
     </property>

     <property name="editor">
       <getter>
         <![CDATA[
          if (this.isHtmlMode)
            return document.getAnonymousElementByAttribute(this, "anonid", "editor");
          else
            return document.getAnonymousElementByAttribute(this, "anonid", "input");
         ]]>
       </getter>
     </property>

     <property name="browser">
       <getter>
         <![CDATA[
            return document.getAnonymousElementByAttribute(this, "anonid", "browser");
         ]]>
       </getter>
     </property>

    </implementation>
    <handlers>
     <handler event="focus" phase="capturing">
       <![CDATA[
         if (event.originalTarget != this)
           return;
         if (!this.hasAttribute("focused")) {
           var input = document.getAnonymousElementByAttribute(this, "anonid", "input");
           this.setAttribute("focused", "true");
           //FIXME: check why it doesn't work without this timeout
           setTimeout(function () {input.focus(); }, 1);
         }
        ]]>
      </handler>
      <handler event="blur" phase="capturing">
        <![CDATA[
          this.removeAttribute("focused");
        ]]>
      </handler>
    </handlers>
  </binding>

  <binding id="convtab" extends="chrome://global/content/bindings/tabbox.xml#tab">
    <resources>
      <stylesheet src="chrome://global/skin/tabbox.css"/>
    </resources>
    <content>
      <xul:hbox class="tab-image-left" xbl:inherits="selected"/>
      <xul:hbox flex="1" class="tab-image-middle" align="center" xbl:inherits="selected">
        <xul:stack class="tab-icon">
          <xul:image xbl:inherits="validate,src=image" class="tab-icon-image"/>
          <xul:image class="tab-extra-status"/>
        </xul:stack>
        <xul:label flex="1" xbl:inherits="value=label,crop,accesskey" crop="right" class="tab-text"/>
      </xul:hbox>
      <xul:hbox class="tab-image-right" xbl:inherits="selected"/>
    </content>
  </binding>
</bindings>
