<?xml version="1.0"?>
<!-- ***** BEGIN LICENSE BLOCK *****
   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
   -
   - The contents of this file are subject to the Mozilla Public License Version
   - 1.1 (the "License"); you may not use this file except in compliance with
   - the License. You may obtain a copy of the License at
   - http://www.mozilla.org/MPL/
   -
   - Software distributed under the License is distributed on an "AS IS" basis,
   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   - for the specific language governing rights and limitations under the
   - License.
   -
   - The Original Code is the Instantbird messenging client, released
   - 2007.
   -
   - The Initial Developer of the Original Code is
   - Florian QUEZE <florian@instantbird.org>.
   - Portions created by the Initial Developer are Copyright (C) 2007
   - the Initial Developer. All Rights Reserved.
   -
   - Contributor(s):
   -
   - Alternatively, the contents of this file may be used under the terms of
   - either the GNU General Public License Version 2 or later (the "GPL"), or
   - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   - in which case the provisions of the GPL or the LGPL are applicable instead
   - of those above. If you wish to allow use of your version of this file only
   - under the terms of either the GPL or the LGPL, and not to allow others to
   - use your version of this file under the terms of the MPL, indicate your
   - decision by deleting the provisions above and replace them with the notice
   - and other provisions required by the GPL or the LGPL. If you do not delete
   - the provisions above, a recipient may use your version of this file under
   - the terms of any one of the MPL, the GPL or the LGPL.
   -
   - ***** END LICENSE BLOCK ***** -->


<!DOCTYPE bindings [
  <!ENTITY % instantbirdDTD SYSTEM "chrome://instantbird/locale/instantbird.dtd">
  %instantbirdDTD;
]>

<bindings id="conversationBindings"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="conversation">
    <resources>
      <stylesheet src="chrome://instantbird/skin/conversation.css"/>
    </resources>
    <content>
      <xul:vbox class="convBox" flex="1">
        <xul:hbox class="conv-top" flex="1">
          <xul:notificationbox class="conv-messages" anonid="convNotificationBox" flex="1">
            <xul:vbox flex="1">
              <xul:browser class="browser" anonid="browser" type="content"
                           flex="1" disablehistory="true"
                           xbl:inherits="tooltip=contenttooltip,contextmenu=contentcontextmenu"/>
              <xul:findbar anonid="FindToolbar" reversed="true"/>
            </xul:vbox>
          </xul:notificationbox>
          <xul:splitter anonid="splitter" collapse="after" class="splitter conv-chat">
            <xul:grippy/>
          </xul:splitter>
          <xul:vbox class="conv-chat" width="150">
            <xul:hbox>
              <xul:label class="header conv-nicklist-header" value="&chat.participants;"/>
              <xul:textbox flex="1" readonly="true" class="plain" anonid="participantCount"/>
            </xul:hbox>
            <xul:listbox anonid="nicklist" class="conv-nicklist"
                         flex="1" seltype="multiple"
                         ondblclick="onNickDblClick(event);"
                         onkeypress="onNicklistKeyPress(event);"/>
          </xul:vbox>
        </xul:hbox>
        <xul:splitter class="splitter"/>
        <xul:deck anonid="conv-bottom" class="conv-bottom" selectedIndex="1">
          <xul:vbox>
            <xul:toolbar anonid="conv-toolbar">
              <xul:toolbarbutton label="Bold" oncommand="this.editorDoCommand('bold');"/>
              <xul:toolbarbutton label="Italic" oncommand="this.editorDoCommand('italic');"/>
              <xul:toolbarbutton label="Underline" oncommand="this.editorDoCommand('underline');"/>
            </xul:toolbar>
            <xul:editor anonid="editor" editortype="html" src="about:blank" flex="1"/>
          </xul:vbox>
          <xul:textbox anonid="input" class="conv-textbox" multiline="true" spellcheck="true" flex="1"/>
        </xul:deck>
      </xul:vbox>
    </content>
    <implementation implements="nsIWebProgressListener,nsIObserver">
     <constructor>
      <![CDATA[
       document.getAnonymousElementByAttribute(this, "anonid", "input")
               .addEventListener("keypress", this.inputKeyPress, false);

       var browser = this.browser;
       browser.addEventListener("keypress", this.browserKeyPress, false);
       browser.addEventListener("scroll", this.browserScroll, false);
       browser.addEventListener("resize", this.browserResize, false);

       var docShell = browser.docShell;
       docShell.allowJavascript = false;
       // We used to block auth requests, plugins, images, subframes and
       // redirects here.
       // We don't need this anymore, our nsIContentPolicy implementation
       // takes care of it

       // load the stylesheet through the style sheet service to workaround
       // a security restriction in 1.9b2+ (bug 397791)
       var sss = Components.classes["@mozilla.org/content/style-sheet-service;1"]
                           .getService(Components.interfaces.nsIStyleSheetService);
       var uri = Components.classes["@mozilla.org/network/io-service;1"]
                           .getService(Components.interfaces.nsIIOService)
                           .newURI("chrome://instantbird/skin/conv.css", null, null);
       if (!sss.sheetRegistered(uri, sss.USER_SHEET))
         sss.loadAndRegisterSheet(uri, sss.USER_SHEET);

       //'data:text/html,<html><head></head><body id="ibcontent"></body></html>';
       var url = "chrome://instantbird/content/conv.html";
       browser.setAttribute("src", url);
       browser.addProgressListener(this);

       var editor = document.getAnonymousElementByAttribute(this, "anonid", "editor");
       editor.addEventListener("keypress", this.editorKeyPress, false);
       //this doesn't work at the moment
       //editor.contentDocument.designMode = "on";
       //setTimeout(function() { editor.contentWindow.focus(); }, 100);

       try {
         this.findbar.browser = browser;
       } catch(e) {
         // Do nothing. The exception is expected and harmless.
         // We call the setter of the browser property of the findbar before
         // the constructor of the findbar is executed.
         // Don't worry, the constructor of the findbar will set again the
         // browser property with a setTimeout call.
       }

       if (!("cleanupImMarkup" in window))
         Components.utils.import("resource://app/modules/imContentSink.jsm");
       if (!("smileImMarkup" in window))
         Components.utils.import("resource://app/modules/imSmileys.jsm");
       if (!("getCurrentTheme" in window))
         Components.utils.import("resource://app/modules/imThemes.jsm");
      ]]>
     </constructor>

     <destructor>
      <![CDATA[
        if (this._conv) {
          this._conv.close();
          this._conv.removeObserver(this);
        }
      ]]>
     </destructor>

     <field name="loaded">false</field>
     <field name="messageQueue">[]</field>
     <field name="_lastMessage">null</field>
     <field name="_statusText">""</field>

     <!-- This is used when we want to remove close the conversation binding
     without closing the associated PurpleConversation.
     For example when quitting the application, we don't want to close the
     conversation. -->
     <method name="unInit">
      <body>
      <![CDATA[
        this._conv.removeObserver(this);
        this._conv = null;
      ]]>
      </body>
     </method>

     <method name="addMsg">
      <parameter name="aMsg"/>
      <body>
      <![CDATA[
        if (this.loaded)
          this._addMsg(aMsg);
        else
          this.messageQueue.push(aMsg);
      ]]>
      </body>
     </method>

     <method name="_addMsg">
      <parameter name="aMsg"/>
      <body>
      <![CDATA[
        var conv = aMsg.conversation;
        if (!conv) {
          // The conversation has already been destroyed,
          // probably because the window was closed.
          // Return without doing anything.
          return;
        }

        let doc = this.browser.contentDocument;
        let msg = cleanupImMarkup(doc, aMsg.message);
        if (!aMsg.noLinkification) {
          msg = Components.classes["@mozilla.org/txttohtmlconv;1"]
                          .getService(Ci.mozITXTToHTMLConv)
                          .scanHTML(msg, 2)
                          .replace(/&amp;(apos|quot);/g, "&$1;");
        }
        msg = msg.replace(/^((<[^>]+>)*)\/me /, "$1").replace(/\n/g, "<br/>");
        aMsg.message = smileImMarkup(doc, msg);
        let next = isNextMessage(this.theme, aMsg, this._lastMessage);
        let html = getHTMLForMessage(aMsg, this.theme, next);

        // FIXME: temporary hack
        let color = "";
        if (!aMsg.system && aMsg.incoming && (conv instanceof Ci.purpleIConvChat))
          color = "color: hsl( " + this.buddies[aMsg.alias || aMsg.who].color + ", 100%, 50%)";
        html = html.replace(/%senderColor%/g, color);

        this._addTxt(html, next);
        this._lastMessage = aMsg;

        if (this.tab && !this.tab.selected && aMsg.incoming && !aMsg.system) {
          if (conv instanceof Ci.purpleIConvChat && aMsg.containsNick)
            this.tab.setAttribute("attention", "true");
          else
            this.tab.setAttribute("unread", "true");
        }
      ]]>
      </body>
     </method>

     <method name="_addTxt">
      <parameter name="aTxt"/>
      <parameter name="aIsNext"/>
      <body>
      <![CDATA[
        if (!this.loaded)
          throw "Trying to append text to a not yet loaded browser";

        let doc = this.browser.contentDocument;
        let elt = doc.getElementsByTagName("body")[0];
        let shouldScroll = this.lastElement ||
                           elt.scrollHeight <= elt.scrollTop + elt.clientHeight + 10;
        let newElt = insertHTMLForMessage(aTxt, doc, aIsNext);
        if (shouldScroll) {
          newElt.scrollIntoView(true);
          this.lastElement = newElt;
          this.scrollingIntoView = true;
        }
      ]]>
      </body>
     </method>

     <method name="sendMsg">
      <parameter name="aMsg"/>
      <body>
      <![CDATA[
        if (!aMsg)
          return;

        var re = /^\/raw (.*)/;
        var msg = aMsg.match(re);
        if (msg)
          msg = msg[1];
        else
          msg = Components.classes["@mozilla.org/txttohtmlconv;1"]
                          .getService(Ci.mozITXTToHTMLConv)
                          .scanTXT(aMsg, 0);
        this._conv.sendMsg(msg);
      ]]>
      </body>
     </method>

     <method name="inputKeyPress">
      <parameter name="event"/>
      <body>
      <![CDATA[
        /* "this" can point to the textbox when this method is used by an eventListener,
            get the conversation element */
        var conv = this;
        if (this.localName != "conversation")
          conv = document.getBindingParent(this);

        if (event.shiftKey && (event.keyCode == KeyEvent.DOM_VK_PAGE_UP ||
                               event.keyCode == KeyEvent.DOM_VK_PAGE_DOWN)) {

          let direction = (event.keyCode == KeyEvent.DOM_VK_PAGE_UP) ? -1 : 1;
          conv.browser.docShell
              .QueryInterface(Components.interfaces.nsITextScroll)
              .scrollByPages(direction);

          event.preventDefault();
          return;
        }

        var input = document.getAnonymousElementByAttribute(conv, "anonid", "input");
        if (event.keyCode != 13) {
          if (conv._conv instanceof Ci.purpleIConvIM)
            setTimeout(function () {
              let text = input.value;
              // try to avoid sending typing notifications when the user is
              // typing a command in the conversation.
              // These checks are not perfect (especially if non-existing
              // commands are sent as regular messages on the in-use prpl).
              if (! /^\//.test(text))
                conv._conv.sendTyping(text.length);
              else
                if (/^\/me /.test(text))
                  conv._conv.sendTyping(text.length - 4);
            }, 0);
          return;
        }

        if (!event.ctrlKey && !event.shiftKey && !event.altKey) {
          conv.sendMsg(input.value);
          input.value = "";
          event.preventDefault();
        }
        else if (!event.shiftKey)
          conv.addString("\n");
      ]]>
      </body>
     </method>

     <method name="editorKeyPress">
      <parameter name="event"/>
      <body>
      <![CDATA[
        if (event.keyCode != 13)
          return;

        /* "this" can point to the textbox when this method is used by an eventListener,
            get the conversation element */
        var conv = this;
        if (this.localName != "conversation")
          conv = document.getBindingParent(this);

        var editor = this.getEditor(this.contentWindow);
        var docRoot = editor.rootElement;

        if (!event.ctrlKey && !event.shiftKey && !event.altKey) {
          conv.sendMsg(docRoot.innerHTML);
          docRoot.innerHTML = "";
          event.preventDefault();
        }
        else {
          if (!event.shiftKey)
            // unfortunately, this doesn't work
            this.contentDocument.execCommand("inserthtml", false, "<br>");
        }
      ]]>
      </body>
     </method>

     <method name="editorDoCommand">
      <parameter name="aCmd"/>
      <parameter name="aHtml"/>
      <body>
      <![CDATA[
        var editor = document.getAnonymousElementByAttribute(this, "anonid", "editor");
        editor.contentDocument.execCommand(aCmd, false, aHtml);
      ]]>
      </body>
     </method>

     <method name="browserScroll">
     <parameter name="event"/>
      <body>
      <![CDATA[
        var conv = document.getBindingParent(this);
        if (conv.scrollingIntoView) {
          // We have explicitely requested a scrollIntoView, ignore the event
          conv.scrollingIntoView = false;
          this.lastScrollHeight = this.scrollHeight;
          this.lastScrollWidth = this.scrollWidth;
          return;
        }

        if (this.lastScrollHeight != this.scrollHeight ||
            this.lastScrollWidth != this.scrollWidth) {
          // if the scrollheight changed, we are resizing the content area,
          // don't stop the auto scroll.
          this.lastScrollHeight = this.scrollHeight;
          this.lastScrollWidth = this.scrollWidth;
          return;
        }

        // Disable auto-scroll, the user moved the scrollbar
        conv.lastElement = null;
      ]]>
      </body>
     </method>

     <method name="browserResize">
     <parameter name="event"/>
      <body>
      <![CDATA[
        var conv = document.getBindingParent(this);
        if (conv.lastElement) {
          // The content area was resized and auto-scroll is enabled,
          // make sure the last inserted element is still visible
          conv.lastElement.scrollIntoView(true);
          conv.scrollingIntoView = true;
        }
      ]]>
      </body>
     </method>

     <method name="browserKeyPress">
     <parameter name="event"/>
      <body>
      <![CDATA[
#ifndef XP_MACOSX
        var accelKeyPressed = event.ctrlKey;
#else
        var accelKeyPressed = event.metaKey;
#endif
        // 118 is the decimal code for "v" character, 13 keyCode for "return" key
        if (((accelKeyPressed && event.charCode != 118) || event.altKey) &&
            event.keyCode != 13)
          return;

        var conv = document.getBindingParent(this);
        var isHtmlMode = conv.isHtmlMode;
        var editor = conv.editor;

        if (event.charCode == 0 &&  // it's not a character, it's a command key
            (event.keyCode != 13 && // Return
             event.keyCode != 8 &&  // Backspace
             event.keyCode != 46))  // Delete
          return;

        editor.focus();

        // Returns for Ctrl+V
        if (accelKeyPressed)
          return;

        const masks = Components.interfaces.nsIDOMNSEvent;
        var modifiers = 0;
        if (event.shiftKey)
          modifiers |= masks.SHIFT_MASK;
        if (event.ctrlKey)
          modifiers |= masks.CONTROL_MASK;
        if (event.altKey)
          modifiers |= masks.ALT_MASK;
        if (event.metaKey)
          modifiers |= masks.META_MASK;
        if (event.accelKey)
          modifiers |= (navigator.platform.indexOf("Mac") >= 0) ? masks.META_MASK
                                                                : masks.CONTROL_MASK;

        // resend the event
        window.QueryInterface(Components.interfaces.nsIInterfaceRequestor)
              .getInterface(Components.interfaces.nsIDOMWindowUtils)
              .sendKeyEvent(event.type, event.keyCode, event.charCode, modifiers);
      ]]>
      </body>
     </method>

     <!-- Replace the current selection in the editor by the given string -->
     <method name="addString">
       <parameter name="aString"/>
       <body>
       <![CDATA[
         var editor = this.editor;
         var length = (aString != "")
                      ? aString.length
                      : 0;

         var cursorPosition = editor.selectionStart + length;

         editor.value = editor.value.substr(0, editor.selectionStart) + aString +
                        editor.value.substr(editor.selectionEnd);
         editor.selectionStart = editor.selectionEnd = cursorPosition;
       ]]>
       </body>
     </method>

     <!-- Update the participant count of a chat conversation -->
     <method name="updateParticipantCount">
       <body>
       <![CDATA[
         document.getAnonymousElementByAttribute(this, "anonid", "participantCount").value =
           this.buddies.__count__;
       ]]>
       </body>
     </method>

     <!-- Set the attributes (flags) of a chat buddy -->
     <method name="setBuddyAttributes">
       <parameter name="aItem"/>
       <body>
       <![CDATA[
         var buddy = aItem.chatBuddy;
         var image;
         if (!buddy.noFlags) {
           if (buddy.op)
             image = "operator";
           else if (buddy.halfOp)
             image = "half-operator";
           else if (buddy.voiced)
             image = "voice";
           else if (buddy.founder)
             image = "founder";
         }
         if (image)
           aItem.setAttribute("image", "chrome://instantbird/skin/" + image + ".png");
         else
           aItem.removeAttribute("image");
       ]]>
       </body>
     </method>

     <!-- Add a buddy in the visible list of participants -->
     <method name="addBuddy">
       <parameter name="aBuddy"/>
       <body>
       <![CDATA[
         var name = aBuddy.name;
         if (this.buddies.hasOwnProperty(name))
           throw "Adding a chat buddy twice?!";
         var item = document.createElement("listitem");
         item.chatBuddy = aBuddy;
         item.setAttribute("class", "listitem-iconic");
         item.setAttribute("label", name);
         this.setBuddyAttributes(item);

         // Compute the color based on the nick
         var nick = name.match(/[a-zA-Z0-9]+/);
         nick = nick ? nick[0].toLowerCase() : nick = name;
         var weight = 10;
         var res = 0;
         for (var i = 0; i < nick.length; ++i) {
           var char = nick.charCodeAt(i) - 47;
           if (char > 10)
             char -= 39;
           // now char contains a value between 1 and 36
           res += char * weight;
           weight *= 0.52; //arbitrary
         }
         res = Math.round(res) % 360;
         var style = "color: hsl(" + res + ", 100%, 50%);";
         item.setAttribute("style", style);
         item.color = res;
         this.buddies[name] = item;

         // Insert item at the right position
         this.addNick(item);
       ]]>
       </body>
     </method>

     <method name="addNick">
       <parameter name="aListItem"/>
       <body>
       <![CDATA[
         var nicklist = document.getAnonymousElementByAttribute(this, "anonid", "nicklist");
         var nick = aListItem.getAttribute("label").toLowerCase();

         // Look for the place of the nick in the list
         var start = 0;
         var end = nicklist.itemCount;
         while (start < end) {
           var middle = start + Math.floor((end - start) / 2);
           if (nick < nicklist.getItemAtIndex(middle)
                              .getAttribute("label").toLowerCase())
             end = middle;
           else
             start = middle + 1;
         }

         // Now insert the element
         if (end == nicklist.itemCount)
           nicklist.appendChild(aListItem);
         else
           nicklist.insertBefore(aListItem, nicklist.getItemAtIndex(end));
       ]]>
       </body>
     </method>

     <!-- Update a buddy in the visible list of participants -->
     <method name="updateBuddy">
       <parameter name="aBuddy"/>
       <parameter name="aOldName"/>
       <body>
       <![CDATA[
         var name = aBuddy.name;
         if (!aOldName) {
           // If aOldName is null, we are changing the flags of the buddy
           var item = this.buddies[name];
           item.chatBuddy = aBuddy;
           this.setBuddyAttributes(item);
           return;
         }

         // Is aOldName is not null, then we are renaming the buddy
         if (!this.buddies.hasOwnProperty(aOldName))
           throw "Updating a chat buddy that does not exist?!";

         if (this.buddies.hasOwnProperty(name))
           throw "Updating a chat buddy to an already existing one?!";

         var item = this.buddies[aOldName];
         item.chatBuddy = aBuddy;
         delete this.buddies[aOldName];
         this.buddies[name] = item;
         item.setAttribute("label", name);

         // Move this item to the right position if its name changed
         var nicklist = document.getAnonymousElementByAttribute(this, "anonid", "nicklist");
         nicklist.removeChild(item);
         this.addNick(item);
       ]]>
       </body>
     </method>
     <method name="removeBuddy">
       <parameter name="aName"/>
       <body>
       <![CDATA[
         if (!this.buddies.hasOwnProperty(aName))
           throw "Cannot remove a buddy that was not in the room";
         var item = this.buddies[aName];
         item.parentNode.removeChild(item);
         delete this.buddies[aName];
       ]]>
       </body>
     </method>

     <method name="updateTopic">
       <body>
       <![CDATA[
          var topic = this._conv.topic;
          if (topic) {
            var box = document.getAnonymousElementByAttribute(this, "anonid", "convNotificationBox");
            var notification = box.getNotificationWithValue("topic");
            if (notification) {
              notification.label = topic;
              return;
            }
            box.appendNotification(topic, "topic", null, box.PRIORITY_INFO_LOW, []);
          }
       ]]>
       </body>
     </method>

     <method name="displayStatusText">
       <body>
       <![CDATA[
         if (!this.tab.selected)
           return;

         if ("XULBrowserWindow" in window)
           window.XULBrowserWindow.setStatus(this._statusText);
       ]]>
       </body>
     </method>

     <method name="updateTyping">
       <body>
       <![CDATA[
          var typingState = this._conv.typingState;
          if (typingState == this.typingState)
            return;

          this.tab.removeAttribute("typing");
          this.tab.removeAttribute("typed");
          this._statusText = "";

          var name = this._conv.title.replace(/^([a-zA-Z0-9.]+)[@\s].*/, "$1");
          if (typingState == Ci.purpleIConvIM.TYPING) {
            this.tab.setAttribute("typing", "true");
            this._statusText = name + " is typing.";
          }
          else if (typingState == Ci.purpleIConvIM.TYPED) {
            this.tab.setAttribute("typed", "true");
            this._statusText = name + " has stopped typing.";
          }

          this.typingState = typingState;
          this.displayStatusText();
       ]]>
       </body>
     </method>

     <!-- nsIObserver implementation -->
     <method name="observe">
       <parameter name="aSubject"/>
       <parameter name="aTopic"/>
       <parameter name="aData"/>
       <body>
       <![CDATA[
         if (!this.loaded)
           return;

         switch(aTopic) {
         case "new-text":
           this._addMsg(aSubject.QueryInterface(Ci.purpleIMessage));
           break;

         case "update-typing":
           this.updateTyping();
           break;

         case "chat-buddy-add":
           aSubject.QueryInterface(Ci.nsISimpleEnumerator);
           while (aSubject.hasMoreElements()) {
             let buddy = aSubject.getNext()
             buddy.QueryInterface(Ci.purpleIConvChatBuddy);
             this.addBuddy(buddy);
           }
           this.updateParticipantCount();
           break;

         case "chat-buddy-remove":
           aSubject.QueryInterface(Ci.nsISimpleEnumerator);
           while (aSubject.hasMoreElements()) {
             let nick = aSubject.getNext();
             nick.QueryInterface(Ci.nsISupportsString);
             this.removeBuddy(nick.toString());
           }
           this.updateParticipantCount();
           break;

         case "chat-buddy-update":
           this.updateBuddy(aSubject.QueryInterface(Ci.purpleIConvChatBuddy), aData);
           break;
         case "chat-update-topic":
           this.updateTopic();
           break;
         }
       ]]>
       </body>
     </method>

     <!-- nsIWebProgressListener implementation -->
     <method name="onStateChange">
      <parameter name="aProgress"/>
      <parameter name="aRequest"/>
      <parameter name="aStateFlags"/>
      <parameter name="aStatus"/>
      <body>
      <![CDATA[
        const WPL = Components.interfaces.nsIWebProgressListener;
        if ((aStateFlags & WPL.STATE_IS_DOCUMENT) &&
            (aStateFlags & WPL.STATE_STOP)) {
          var browser = this.browser;
          browser.removeProgressListener(this);
          this.theme = getCurrentTheme();
          initHTMLDocument(this.conv, this.theme, browser.contentDocument);
          this.loaded = true;
          for (var i = 0; i < this.messageQueue.length; ++i)
            this._addMsg(this.messageQueue[i]);
          this.messageQueue = null;

          if (this._conv instanceof Components.interfaces.purpleIConvChat) {
            this.updateTopic();
            this.setAttribute("chat", "true");
            this.buddies = {};
            var nicks = getIter(this.conv.getParticipants, Ci.purpleIConvChatBuddy);
            for (let n in nicks)
              this.addBuddy(n);
            this.updateParticipantCount();
          }
        }
      ]]>
      </body>
     </method>

     <method name="onProgressChange">
      <parameter name="aProgress"/>
      <parameter name="aRequest"/>
      <parameter name="aCurSelf"/>
      <parameter name="aMaxSelf"/>
      <parameter name="aCurTotal"/>
      <parameter name="aMaxTotal"/>
     </method>

     <method name="onLocationChange">
      <parameter name="aProgress"/>
      <parameter name="aRequest"/>
      <parameter name="aLocation"/>
     </method>

     <method name="onStatusChange">
      <parameter name="aProgress"/>
      <parameter name="aRequest"/>
      <parameter name="aStatus"/>
      <parameter name="aMessage"/>
     </method>

     <method name="onSecurityChange">
      <parameter name="aProgress"/>
      <parameter name="aRequest"/>
      <parameter name="aState"/>
     </method>

     <method name="onNicklistKeyPress">
      <parameter name="event"/>
      <body>
      <![CDATA[
        if (event.keyCode != 13)
          return;

        // Return is pressed
        var conv = this;
        if (this.localName != "conversation")
          conv = document.getBindingParent(this);
        var listbox = event.originalTarget;
        for (var i = 0; i < listbox.selectedCount; ++i) {
          var nick = listbox.getSelectedItem(i).chatBuddy.name;
          conv._conv.account.createConversation(nick);
        }
      ]]>
      </body>
     </method>

     <method name="onNickDblClick">
      <parameter name="event"/>
      <body>
      <![CDATA[
        var nick = event.originalTarget.chatBuddy.name;
        this._conv.account.createConversation(nick);
      ]]>
      </body>
     </method>

     <property name="convId">
       <getter>
         <![CDATA[
           return this._conv.id;
         ]]>
       </getter>
     </property>

     <property name="conv">
       <getter>
         <![CDATA[
           return this._conv;
         ]]>
       </getter>
       <setter>
         <![CDATA[
           if (this._conv)
             throw("Already initialized");
           this._conv = val;
           this._conv.addObserver(this);
           return val;
         ]]>
       </setter>
     </property>

     <property name="isHtmlMode">
       <getter>
         <![CDATA[
           var editorIndex = document.getAnonymousElementByAttribute(this, "anonid", "conv-bottom")
                                     .selectedIndex;
           return (editorIndex == "0");
         ]]>
       </getter>
     </property>

     <property name="editor">
       <getter>
         <![CDATA[
          if (this.isHtmlMode)
            return document.getAnonymousElementByAttribute(this, "anonid", "editor");
          else
            return document.getAnonymousElementByAttribute(this, "anonid", "input");
         ]]>
       </getter>
     </property>

     <property name="browser">
       <getter>
         <![CDATA[
          return document.getAnonymousElementByAttribute(this, "anonid", "browser");
         ]]>
       </getter>
     </property>

     <property name="findbar">
       <getter>
         <![CDATA[
          return document.getAnonymousElementByAttribute(this, "anonid", "FindToolbar");
         ]]>
       </getter>
     </property>

    </implementation>
    <handlers>
     <handler event="focus" phase="capturing">
       <![CDATA[
         if (event.originalTarget != this)
           return;
         if (!this.hasAttribute("focused")) {
           var input = document.getAnonymousElementByAttribute(this, "anonid", "input");
           this.setAttribute("focused", "true");
           this.displayStatusText();
           //FIXME: check why it doesn't work without this timeout
           setTimeout(function () {input.focus(); }, 1);
         }
        ]]>
      </handler>
      <handler event="blur" phase="capturing">
        <![CDATA[
          this.removeAttribute("focused");
        ]]>
      </handler>
    </handlers>
  </binding>

  <binding id="convtab" extends="chrome://global/content/bindings/tabbox.xml#tab">
    <resources>
      <stylesheet src="chrome://global/skin/tabbox.css"/>
    </resources>
    <content>
      <xul:hbox class="tab-image-left" xbl:inherits="selected"/>
      <xul:hbox flex="1" class="tab-image-middle" align="center" xbl:inherits="selected">
        <xul:stack class="tab-icon">
          <xul:image xbl:inherits="validate,src=image" class="tab-icon-image"/>
          <xul:image class="tab-extra-status"/>
        </xul:stack>
        <xul:label flex="1" xbl:inherits="value=label,crop,accesskey" crop="right" class="tab-text"/>
      </xul:hbox>
      <xul:hbox class="tab-image-right" xbl:inherits="selected"/>
    </content>
  </binding>
</bindings>
