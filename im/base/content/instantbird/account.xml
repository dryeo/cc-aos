<?xml version="1.0"?>
<!-- ***** BEGIN LICENSE BLOCK *****
   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
   -
   - The contents of this file are subject to the Mozilla Public License Version
   - 1.1 (the "License"); you may not use this file except in compliance with
   - the License. You may obtain a copy of the License at
   - http://www.mozilla.org/MPL/
   -
   - Software distributed under the License is distributed on an "AS IS" basis,
   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   - for the specific language governing rights and limitations under the
   - License.
   -
   - The Original Code is the Instantbird messenging client, released
   - 2007.
   -
   - The Initial Developer of the Original Code is
   - Florian QUEZE <florian@instantbird.org>.
   - Portions created by the Initial Developer are Copyright (C) 2007
   - the Initial Developer. All Rights Reserved.
   -
   - Contributor(s):
   -
   - Alternatively, the contents of this file may be used under the terms of
   - either the GNU General Public License Version 2 or later (the "GPL"), or
   - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   - in which case the provisions of the GPL or the LGPL are applicable instead
   - of those above. If you wish to allow use of your version of this file only
   - under the terms of either the GPL or the LGPL, and not to allow others to
   - use your version of this file under the terms of the MPL, indicate your
   - decision by deleting the provisions above and replace them with the notice
   - and other provisions required by the GPL or the LGPL. If you do not delete
   - the provisions above, a recipient may use your version of this file under
   - the terms of any one of the MPL, the GPL or the LGPL.
   -
   - ***** END LICENSE BLOCK ***** -->


<!DOCTYPE bindings [
  <!ENTITY % accountsDTD SYSTEM "chrome://instantbird/locale/accounts.dtd">
  %accountsDTD;
]>

<bindings id="accountBindings"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="account" extends="chrome://global/content/bindings/richlistbox.xml#richlistitem">
    <content>
      <xul:vbox flex="1">
        <xul:hbox flex="1">
          <xul:vbox flex="1">

           <xul:hbox class="accountNameBox">
            <xul:label value="&account.name;" class="accountNameLabel"/>
            <xul:label flex="1" xbl:inherits="value=name"
                       class="accountName"/>
           </xul:hbox>
           <xul:hbox class="accountAliasBox">
            <xul:label value="&account.alias;"/>
            <xul:label flex="1" xbl:inherits="value=alias"
                       class="accountAlias"/>
           </xul:hbox>
           <xul:label class="connecting" anonid="connecting" value="&account.connecting;"/>
           <xul:label class="connected" value="&account.connected;"/>
           <xul:label class="disconnecting" value="&account.disconnecting;"/>
           <xul:label class="disconnected" value="&account.disconnected;"/>
           <xul:description class="error" anonid="error"/>
           <xul:description class="error" anonid="reconnect"/>
           <xul:spacer flex="1"/>
          </xul:vbox>
          <xul:vbox align="center">
            <xul:stack>
              <xul:image xbl:inherits="src=prplicon" class="accountIcon"/>
              <xul:image xbl:inherits="src=prplicon" class="accountIconAnim"
                         anonid="prplicon"/>
              <xul:image src="chrome://instantbird/skin/accountError.png" class="errorIcon"/>
            </xul:stack>
            <xul:label xbl:inherits="value=protocol" class="prplName"/>
          </xul:vbox>
        </xul:hbox>
        <xul:hbox flex="1" class="account-buttons">
          <xul:checkbox label="&account.autoSignOn;"
                        xbl:inherits="checked=autologin"
                        oncommand="gAccountManager.autologin()"/>
          <xul:spacer flex="1"/>
          <xul:button class="disconnectButton"
                      label="&account.disconnect.label;"
                      accesskey="&account.disconnect.accesskey;"
                      oncommand="gAccountManager.disconnect()"
                      anonid="disconnect"/>
          <xul:button class="connectButton"
                      label="&account.connect.label;"
                      accesskey="&account.connect.accesskey;"
                      oncommand="gAccountManager.connect()"
                      anonid="connect"/>
          <xul:button label="&account.delete.label;"
                      accesskey="&account.delete.accesskey;"
                      oncommand="gAccountManager.delete()"/>
          <xul:button label="&account.edit.label;"
                      accesskey="&account.edit.accesskey;"
                      oncommand="gAccountManager.edit()"/>
        </xul:hbox>
      </xul:vbox>
    </content>
    <implementation>
     <field name="_disabledDelay">500</field>

     <method name="build">
      <parameter name="aAccount"/>
      <body>
      <![CDATA[
        this._account = aAccount;
        this.setAttribute("name", aAccount.name);
        this.setAttribute("id", aAccount.id);
        var alias = aAccount.alias; 
        if (alias)
          this.setAttribute("alias", alias);
        else
          this.removeAttribute("alias");
        var proto = aAccount.protocol;
        this.setAttribute("protocol", proto.name);
        this.setAttribute("prplicon", proto.iconBaseURI + "icon32.png");
        var state = "Unknown";
        if (this._account.connected) {
          state = "connected"
        } else if (this._account.disconnected) {
          state = "disconnected"
          if (this._account.connectionErrorReason != Ci.purpleIAccount.NO_ERROR)
            this.updateConnectionError();
        } else if (this._account.connecting) {
          state = "connecting"
          document.getAnonymousElementByAttribute(this, "anonid", "prplicon").animate();
          this.updateConnectionState();
        } else if (this._account.disconnecting) {
          state = "connected"
        }
        //dump("state = " + state + "\n");
        this.setAttribute("state", state);
        this.autoLogin = aAccount.autoLogin;
      ]]>
      </body>
     </method>

     <method name="connect">
      <body>
      <![CDATA[
        if (this._account.disconnected) {
          var disconnect = document.getAnonymousElementByAttribute(this, "anonid", "disconnect");
          disconnect.setAttribute("disabled", "true");

          setTimeout(function(aDisconnect) {
                       aDisconnect.removeAttribute("disabled");
                     }, this._disabledDelay, disconnect);

          this._account.connect();
        }
      ]]>
      </body>
     </method>

     <method name="disconnect">
      <body>
      <![CDATA[
        var acc = this._account;
        if (acc.connected || acc.connecting) {
          var connect = document.getAnonymousElementByAttribute(this, "anonid", "connect");
          connect.setAttribute("disabled", "true");

          setTimeout(function(aConnect) {
                       aConnect.removeAttribute("disabled");
                     }, this._disabledDelay, connect);

          this._account.disconnect();
        }
      ]]>
      </body>
     </method>

     <method name="delete">
      <body>
      <![CDATA[
        var prefs = Components.classes["@mozilla.org/preferences-service;1"]
                              .getService(Components.interfaces.nsIPrefBranch);

        var showPrompt = prefs.getBoolPref("messenger.accounts.promptOnDelete");
        if (showPrompt) {
          var prompts = Components.classes["@mozilla.org/embedcomp/prompt-service;1"]
                                  .getService(Components.interfaces.nsIPromptService);

          var bundle = document.getElementById("accountsBundle");
          var promptTitle    = bundle.getString("account.deletePrompt.title");
          var promptMessage  = bundle.getString("account.deletePrompt.message");
          var promptCheckbox = bundle.getString("account.deletePrompt.checkbox");
          var deleteButton   = bundle.getString("account.deletePrompt.button");

          var checkbox = {};
          var flags = prompts.BUTTON_TITLE_IS_STRING * prompts.BUTTON_POS_0 +
                      prompts.BUTTON_TITLE_CANCEL * prompts.BUTTON_POS_1;
          if (prompts.confirmEx(window, promptTitle, promptMessage, flags,
                                deleteButton, null, null, promptCheckbox, checkbox))
            return;

          if (checkbox.value)
            prefs.setBoolPref("messenger.accounts.promptOnDelete", false);
        }

        var pcs = Components.classes["@instantbird.org/purple/core;1"]
                            .getService(Ci.purpleICoreService);
        pcs.deleteAccount(this._account.id);
      ]]>
      </body>
     </method>

     <method name="updateConnectionState">
      <body>
      <![CDATA[
        var bundle = document.getElementById("accountsBundle");
        const key = "account.connection.progress";
        var text = this._account.connectionStateMsg;
        text = text ? bundle.getFormattedString(key, [text])
                    : bundle.getString("account.connecting");

        var progress = document.getAnonymousElementByAttribute(this, "anonid",
                                                               "connecting");
        progress.setAttribute("value", text);
        clearInterval(this.reconnectUpdateInterval);
        delete this.reconnectUpdateInterval;
      ]]>
      </body>
     </method>

     <method name="updateConnectionError">
      <body>
      <![CDATA[
        var bundle = document.getElementById("accountsBundle");
        const key = "account.connection.error";
        var account = this._account;
        var text;
        if (account.connectionErrorReason == Ci.purpleIAccount.ERROR_UNKNOWN_PRPL) {
          document.getAnonymousElementByAttribute(this, "anonid", "connect")
                  .setAttribute("disabled", "true");
          text = bundle.getFormattedString(key + "UnknownPrpl",
                                           [account.protocol.id]);
        }
        else
          text = account.connectionErrorMessage;
        text = bundle.getFormattedString(key, [text]);

        this.setAttribute("error", "true");
        var error = document.getAnonymousElementByAttribute(this, "anonid",
                                                            "error");
        error.textContent = text;

        var reconnectElt = document.getAnonymousElementByAttribute(this,"anonid",
                                                                   "reconnect");
        var updateReconnect = function() {
          var date = Math.round((account.timeOfNextReconnect - Date.now()) / 1000);
          let reconnect = "";
          if (date > 0) {
            let [val1, unit1, val2, unit2] = DownloadUtils.convertTimeUnits(date);
            if (!val2)
              reconnect = bundle.getFormattedString("account.reconnectInSingle",
                                                    [val1, unit1])
            else
              reconnect = bundle.getFormattedString("account.reconnectInDouble",
                                                    [val1, unit1, val2, unit2])
          }
          reconnectElt.textContent = reconnect;
          return reconnect;
        };
        if (updateReconnect() && !this.reconnectUpdateInterval)
          this.reconnectUpdateInterval = setInterval(updateReconnect, 1000);
      ]]>
      </body>
     </method>

     <method name="observe">
      <parameter name="aSubject"/>
      <parameter name="aTopic"/>
      <parameter name="aData"/>
      <body>
      <![CDATA[
        if (aTopic == "account-updated") {
          this.build(aSubject);
          return;
        }

        const stateEvents = {
          "account-connected": "connected",
          "account-connecting": "connecting",
          "account-disconnected": "disconnected",
          "account-disconnecting": "disconnecting"
        };
        if (aTopic in stateEvents) {
          /* handle protocol icon animation while connecting */
          var icon = document.getAnonymousElementByAttribute(this, "anonid",
                                                             "prplicon");
          if (aTopic == "account-connecting") {
            icon.animate();
            this.removeAttribute("error");
            this.updateConnectionState();
          }
          else
            icon.stop();

          this.setAttribute("state", stateEvents[aTopic]);
        }
        else if (aTopic == "account-connect-progress") {
          this.updateConnectionState();
        }
        else if (aTopic == "account-connect-error") {
          this.updateConnectionError();
        }
      ]]>
      </body>
     </method>

     <property name="autoLogin">
       <getter>
         <![CDATA[
           return this.hasAttribute("autologin");
         ]]>
       </getter>
       <setter>
         <![CDATA[
           if (val)
             this.setAttribute("autologin", "true");
           else
             this.removeAttribute("autologin");
           if (this._account.autoLogin != val)
             this._account.autoLogin = val;
           return val;
         ]]>
       </setter>
     </property>

     <property name="account">
       <getter>
         <![CDATA[
           return this._account;
         ]]>
       </getter>
     </property>

    </implementation>
    <handlers>
      <handler event="dblclick">
        <![CDATA[
          // If we double clicked on a widget that has already done
          // something with the first click, we should ignore the event
          var localName = event.originalTarget.localName;
          if (localName != "button" && localName != "checkbox")
            gAccountManager.edit();

          // Prevent from loading an account wizzard
          event.stopPropagation();
        ]]>
      </handler>
    </handlers>
  </binding>
</bindings>
