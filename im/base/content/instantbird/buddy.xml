<?xml version="1.0"?>
<!-- ***** BEGIN LICENSE BLOCK *****
   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
   -
   - The contents of this file are subject to the Mozilla Public License Version
   - 1.1 (the "License"); you may not use this file except in compliance with
   - the License. You may obtain a copy of the License at
   - http://www.mozilla.org/MPL/
   -
   - Software distributed under the License is distributed on an "AS IS" basis,
   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   - for the specific language governing rights and limitations under the
   - License.
   -
   - The Original Code is the Instantbird messenging client, released
   - 2007.
   -
   - The Initial Developer of the Original Code is
   - Florian QUEZE <florian@instantbird.org>.
   - Portions created by the Initial Developer are Copyright (C) 2007
   - the Initial Developer. All Rights Reserved.
   -
   - Contributor(s):
   -
   - Alternatively, the contents of this file may be used under the terms of
   - either the GNU General Public License Version 2 or later (the "GPL"), or
   - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   - in which case the provisions of the GPL or the LGPL are applicable instead
   - of those above. If you wish to allow use of your version of this file only
   - under the terms of either the GPL or the LGPL, and not to allow others to
   - use your version of this file under the terms of the MPL, indicate your
   - decision by deleting the provisions above and replace them with the notice
   - and other provisions required by the GPL or the LGPL. If you do not delete
   - the provisions above, a recipient may use your version of this file under
   - the terms of any one of the MPL, the GPL or the LGPL.
   -
   - ***** END LICENSE BLOCK ***** -->

<!DOCTYPE bindings [
  <!ENTITY % buddyDTD SYSTEM "chrome://instantbird/locale/buddy.dtd">
  %buddyDTD;
]>

<bindings id="buddyBindings"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl"
          xmlns:html="http://www.w3.org/1999/xhtml">

  <binding id="buddy" extends="chrome://global/content/bindings/richlistbox.xml#richlistitem">
    <content>
      <xul:hbox tooltip="_child" flex="1">

        <xul:tooltip onpopupshowing="updateTooltip();" anonid="buddytooltip" noautohide="true">

          <xul:hbox pack="start" align="start" flex="1">

            <xul:vbox flex="1">
              <xul:hbox crop="end" align="center" flex="1">
                <xul:stack class="prplBuddyIcon">
                  <xul:image xbl:inherits="src=iconPrpl" class="protoIcon"/>
                  <xul:image class="statusIcon"/>
                </xul:stack>
                <xul:description xbl:inherits="value=displayname" class="tooltip-header"/>
              </xul:hbox>

              <xul:grid>
                <xul:columns>
                  <xul:column/>
                  <xul:column flex="1"/>
                </xul:columns>
                <xul:rows anonid="tooltiprows">
                  <xul:row xbl:inherits="hidden=buddyHidden">
                    <xul:label value="&buddy.screenname;" class="header"/>
                    <xul:description><xul:text xbl:inherits="value=buddy"/></xul:description>
                  </xul:row>
                  <xul:row xbl:inherits="hidden=loggedInHidden">
                    <xul:label value="&buddy.loggedIn;" class="header"/>
                    <xul:description><xul:text xbl:inherits="value=loggedIn"/></xul:description>
                  </xul:row>
                  <xul:row>
                    <xul:label value="&buddy.account;" class="header"/>
                    <xul:description><xul:text xbl:inherits="value=accountName"/></xul:description>
                  </xul:row>
                </xul:rows>
              </xul:grid>
            </xul:vbox>

            <xul:vbox align="end" pack="start" flex="1" style="margin: 0 0; display:block;">
              <html:img anonid="userIcon"/>
            </xul:vbox>
          </xul:hbox>

        </xul:tooltip>

        <xul:stack class="prplBuddyIcon">
          <xul:image xbl:inherits="src=iconPrpl" class="protoIcon"/>
          <xul:image class="statusIcon"/>
        </xul:stack>
        <xul:label crop="end" flex="1" class="buddyDisplayName" xbl:inherits="value=displayname"/>
        <!--<xul:textbox collapsed="true" class="plain" xbl:inherits="value=displayname"/>-->
      </xul:hbox>
    </content>
    <implementation>
     <constructor>
      <![CDATA[
       //dump("constructing buddy\n");
     ]]>
     </constructor>
     <destructor>
      <![CDATA[
       //dump("destructing buddy\n");
     ]]>
     </destructor>

     <!-- delay in milliseconds before starting the fade out animation -->
     <field name="animationDelay">1000</field>

     <!-- delay between each frame of the animation, in milliseconds -->
     <field name="animationInterval">20</field>

     <method name="build">
      <parameter name="aBuddy"/>
      <parameter name="aGroup"/>
      <body>
      <![CDATA[
        this.group = aGroup;
        this.buddyId = aBuddy.id;
        this.name = aBuddy.name;
        this.alias = aBuddy.alias;
        this.setAttribute("displayname", this.alias || this.name);
        if (this.alias != this.name)
          this.setAttribute("buddy", this.name);
        else
          this.setAttribute("buddyHidden", "true");
        //this.setAttribute("id", "buddy" + this.buddyId);
        let account = aBuddy.getAccount(0);
        this.setAttribute("accountName", account.name);
        this.setAttribute("iconPrpl", account.protocol.iconBaseURI + "icon.png");
        this.accounts = { };
        this.accountsCount = 0;
        // We don't call this.update yet because this.accounts is empty
#ifndef WINCE
        // Don't do the animation if inside a closed group
        if (this.hasAttribute("collapsed"))
          return;

        this.style.height = (this.animHeight = 0) + "px";
        this.setAttribute("expanding", "true");
        this.animInterval = setInterval(this._animateExpand, this.animationInterval, this);
#endif
      ]]>
      </body>
     </method>

     <method name="update">
      <body>
      <![CDATA[
        var away = true;
        for (var id in this.accounts)
          if (this.accounts[id].available) {
            away = false;
            break;
          }
        if (away) {
          var status;
          for (var id in this.accounts) {
            status = this.accounts[id].status;
            if (status)
              break;
          }
          this.setAttribute("away", "true");
        }
        else
          this.removeAttribute("away");

        var idle = true;
        for (var id in this.accounts)
          if (!this.accounts[id].idle) {
            idle = false;
            break;
          }
        if (idle)
          this.setAttribute("idle", "true");
        else
          this.removeAttribute("idle");

        var tooltip = document.getAnonymousElementByAttribute(this, "anonid",
                                                              "buddytooltip");
        if (tooltip.state == "open")
          this.updateTooltip();
      ]]>
      </body>
     </method>
     <method name="updateTooltip">
      <body>
      <![CDATA[
        // We can't rely on the first purpleAccountBuddy listed in the
        // purpleBuddy structure because it may not be online

        var buddy;
        for (var id in this.accounts) {
          buddy = this.accounts[id];
          break;
        }
        if (!buddy)
          throw "no account in this buddy!";

        var loggedIn = buddy.loggedIn;

        if (loggedIn) {
          this.setAttribute("loggedIn", loggedIn);
          this.setAttribute("loggedInHidden", false);
        } else {
          this.setAttribute("loggedInHidden", true);
          this.removeAttribute("loggedIn");
        }
        var img = document.getAnonymousElementByAttribute(this, "anonid",
                                                          "userIcon");
        var src = buddy.buddyIconFilename;
        if (src) {
          const maxSize = 48;
          img.src = src;
          var height = img.naturalHeight || maxSize;
          var width = img.naturalWidth || maxSize;
          if (height > maxSize || width > maxSize) {
            var ratio = Math.max(height, width);
            height = height / ratio * maxSize;
            width  = width  / ratio * maxSize;
          }
          img.parentNode.width = width; //XXXFLo hack to workaround a bug
          img.height = height;
        }
        else
          img.hidden = true;

        var rows = document.getAnonymousElementByAttribute(this, "anonid",
                                                           "tooltiprows");
        var row = rows.firstChild;
        while (row) {
          var currentRow = row;
          row = row.nextSibling;
          if (currentRow.className == "generated")
            currentRow.parentNode.removeChild(currentRow);
        }
        
        const XULNS =
          "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
        var tooltipInfo = buddy.getTooltipInfo();
        if (!tooltipInfo)
          return true;

        while (tooltipInfo.hasMoreElements()) {
          var row = document.createElementNS(XULNS, "row");
          row.className = "generated";
          var elt = tooltipInfo.getNext().QueryInterface(Ci.purpleITooltipInfo);
          switch (elt.type) {
            case Ci.purpleITooltipInfo.pair:
            case Ci.purpleITooltipInfo.sectionHeader:
              var label = document.createElementNS(XULNS, "label");
              label.className = "header";
              label.setAttribute("value", elt.label);
              row.appendChild(label);
              label = document.createElementNS(XULNS, "description");
              label.textContent = elt.value;
              row.appendChild(label);
              break;
            case Ci.purpleITooltipInfo.sectionBreak:
              var separator = document.createElementNS(XULNS, "separator");
              separator.className = "thin";
              row.appendChild(separator);
              break;
          }
          rows.appendChild(row);
        }

        return true;
      ]]>
      </body>
     </method>

     <method name="addAccount">
      <parameter name="aPab"/>
      <body>
      <![CDATA[
        var id = aPab.account.id;
        if (id in this.accounts)
          throw "This buddy has already been added";
        this.accounts[id] = aPab;
        ++this.accountsCount;
        this.update();

        if (this.hasAttribute("removing")) {
          this.removeAttribute("offline");
          this.removeAttribute("removing");
          this.removeAttribute("collapsing");
          if (this.animTimeout) {
            clearTimeout(this.animTimeout);
            delete this.animTimeout;
          }
          if (this.animInterval) {
            clearInterval(this.animInterval);
            delete this.animTimeout;
            delete this.animOpacity;
            delete this.animHeight;
            this.style.opacity = 1;
          }
        }
      ]]>
      </body>
     </method>

     <method name="removeAccount">
      <parameter name="aPab"/>
      <body>
      <![CDATA[
        var id = aPab.account.id;
        if (!(id in this.accounts))
          return; // this used to throw, but this seems to be harmless
          //throw "This buddy (" + aPab.buddy.name +
                  ") has not been added for account " + aPab.account.name;

        delete this.accounts[id];
        --this.accountsCount;

        if (this.accountsCount) {
          this.update();
          return;
        }

        // No account left, this node is now useless, remove it
        this.removing = true;
        if (this.hasAttribute("expanding")) {
           // We are still doing the expand animation!
           clearInterval(this.animInterval);
           this.setAttribute("collapsing", "true");
           this.removeAttribute("expanding", "true");
           this.animInterval = setInterval(this._animateCollapse, this.animationInterval, this);
           this.group.removeBuddy(this);
        }
        else if (this.hasAttribute("collapsed"))
          // If the buddy is not visible, remove it immediately (without animation)
          this.group.removeBuddy(this);
        else
          this.animTimeout = setTimeout(this._startAnimation, this.animationDelay, this);
        this.setAttribute("offline", "true");
        this.setAttribute("removing", "true");
      ]]>
      </body>
     </method>

     <method name="_startAnimation">
      <parameter name="aThis"/>
      <body>
       <![CDATA[
        aThis.animInterval = setInterval(aThis._animateFade, this.animationInterval, aThis);
        delete aThis.animTimeout;
        aThis.animOpacity = 1;
       ]]>
      </body>
     </method>

     <method name="_animateFade">
      <parameter name="aThis"/>
      <body>
       <![CDATA[
         const opacityStep = 0.05;
         if (aThis.animOpacity > opacityStep) {
           aThis.animOpacity -= opacityStep;
           aThis.style.opacity = aThis.animOpacity;
         }
         else {
           clearInterval(aThis.animInterval);
           aThis.style.height = (aThis.animHeight = aThis.clientHeight) + "px";
           aThis.setAttribute("collapsing", "true");
           aThis.animInterval = setInterval(aThis._animateCollapse, this.animationInterval, aThis);
           aThis.group.removeBuddy(aThis);
         }
      ]]>
      </body>
     </method>

     <method name="_animateCollapse">
      <parameter name="aThis"/>
      <body>
       <![CDATA[
         const collapsingStep = 3;
         if (aThis.animHeight > collapsingStep) {
           aThis.animHeight -= collapsingStep;
           aThis.style.height = aThis.animHeight + "px";
         }
         else {
           clearInterval(aThis.animInterval);
           delete aThis.animInterval;
           aThis.parentNode.removeChild(aThis);
         }
      ]]>
      </body>
     </method>

     <method name="_animateExpand">
      <parameter name="aThis"/>
      <body>
       <![CDATA[
         const expandingStep = 3;
         if (aThis.animHeight < 20 - expandingStep) {
           aThis.animHeight += expandingStep;
           aThis.style.height = aThis.animHeight + "px";
         }
         else {
           clearInterval(aThis.animInterval);
           delete aThis.animInterval;
           aThis.removeAttribute("expanding");
         }
      ]]>
      </body>
     </method>

     <method name="openConversation">
      <body>
       <![CDATA[
         var pcs = Components.classes["@instantbird.org/purple/core;1"]
                             .getService(Components.interfaces.purpleICoreService);
         var buddy = pcs.getBuddyById(this.buddyId);
         var conv;
         for (var id in this.accounts) {
           // this will send a new-conversation notification that will force
           // opening a conversation window if there isn't one around
           conv = this.accounts[id].createConversation();
           break;
         }

         Conversations.focusConversation(conv);
       ]]>
      </body>
     </method>
    </implementation>
    <handlers>
     <handler event="click" clickcount="2" action="openConversation();"/>
    </handlers>
  </binding>
</bindings>
